#!/usr/bin/env python
import os
import re
import numpy as np
from typing import Tuple, Optional, List
import cv2  # Ensure cv2 is imported at the top level if not already
from utils.preprocessing import simulate_low_field_mri, simulate_15T_data, robust_normalize, letterbox_resize, InterpolationMethod  # Import simulation and normalization functions

def generate_bids_identifier(nifti_file: str) -> str:
    """
    Extract a robust identifier from a NIfTI filename, 
    parsing BIDS-like entities (sub, ses, task, acq, run, etc.).
    
    Args:
        nifti_file: Path to the NIfTI file
        
    Returns:
        A unique identifier string derived from the filename
    """
    # Get the filename without the full path
    basename = os.path.basename(nifti_file)
    
    # Remove the extension(s)
    # Handle both .nii and .nii.gz extensions
    if basename.endswith('.nii.gz'):
        basename = basename[:-7]
    elif basename.endswith('.nii'):
        basename = basename[:-4]
    
    # For BIDS formatted filenames (e.g., sub-01_ses-1_acq-MPRAGE_T1w.nii.gz)
    # Extract all entities using a regex pattern
    # BIDS entities are in the format key-value
    bids_entities = re.findall(r'([a-zA-Z0-9]+)-([a-zA-Z0-9]+)', basename)
    
    # If BIDS entities were found, create an identifier 
    if bids_entities:
        # Join all entities to form the identifier
        # Filter out modality entities (like T1w, T2w) which typically come after underscores
        # These are not typically in key-value format and are handled separately
        base_id = '_'.join([f"{key}-{value}" for key, value in bids_entities])
        
        # Look for modality suffix (typically after the last underscore)
        modality_match = re.search(r'_([A-Za-z0-9]+)$', basename)
        if modality_match:
            modality = modality_match.group(1)
            # Only add modality if it's a standard MRI modality identifier
            if modality in ['T1w', 'T2w', 'FLAIR', 'BOLD', 'PD', 'PDw', 'DWI']:
                base_id += f"_{modality}"
                
        return base_id
    
    # For non-BIDS filenames, just return the basename without extension
    return basename

def generate_filename(subject: str, slice_idx: int, timepoint: Optional[int] = None) -> str:
    """
    Generate a filename with the following format:
      SubjectName[_T{timepoint}]_s{slice_idx:03d}.png
    (No modality suffix is added so that paired images have identical names.)
    
    Args:
        subject: Subject identifier
        slice_idx: Slice index
        timepoint: Optional timepoint for 4D data
        
    Returns:
        Formatted filename string
    """
    if timepoint is not None:
        return f"{subject}_T{timepoint}_s{slice_idx:03d}.png"
    else:
        return f"{subject}_s{slice_idx:03d}.png"

def extract_slices_3d(data: np.ndarray, 
                      subject: str, 
                      hr_output_dir: str,
                      lr_output_dir: Optional[str] = None,
                      timepoint: Optional[int] = None,
                      n_slices: int = 10, 
                      lower_percent: float = 0.2, 
                      upper_percent: float = 0.8, 
                      target_size: Tuple[int, int] = (320, 240),
                      preprocess_function=None,
                      apply_simulation: bool = False, # Note: apply_simulation in preprocess_function is now only for HR
                      noise_std: float = 5.0,
                      blur_sigma: float = 0.5,
                      kspace_crop_factor: float = 0.5,
                      use_kspace_simulation: bool = True):
    """
    Extract n_slices equally spaced from the central portion of a 3D volume,
    preprocess (using the provided preprocessing function),
    and save each slice in high-resolution (HR) and optionally low-resolution (LR) formats.
    LR images are generated by applying simulation and then downsampling the result by 2x.
    
    Args:
        data: 3D numpy array with volume data
        subject: Subject identifier for filename generation
        hr_output_dir: Directory to save high-resolution processed slices
        lr_output_dir: Directory to save low-resolution processed slices (if None, only save HR)
        timepoint: Optional timepoint for 4D data
        n_slices: Number of slices to extract
        lower_percent: Lower percentile of slices to consider
        upper_percent: Upper percentile of slices to consider
        target_size: Target size for HR resizing as (width, height)
        preprocess_function: Function to preprocess each slice (should return HR slice at target_size)
        apply_simulation: Whether to generate and save LR images (simulation settings below are used if True)
        noise_std: Noise standard deviation for simulation
        blur_sigma: Sigma for Gaussian blur in simulation (if use_kspace_simulation=False)
        kspace_crop_factor: Factor to determine how much of k-space to keep (if use_kspace_simulation=True)
        use_kspace_simulation: Whether to use k-space based simulation (True) or blur+noise (False)
    """
    # If no preprocessing function provided, raise an error
    if preprocess_function is None:
        raise ValueError("A preprocessing function must be provided")
    
    num_slices = data.shape[2]
    lower_index = int(lower_percent * num_slices)
    upper_index = int(upper_percent * num_slices)
    slice_indices = np.linspace(lower_index, upper_index, n_slices, dtype=int)

    # Import cv2 locally within the function if preferred, or ensure it's imported globally
    # import cv2 
    
    for idx in slice_indices:
        slice_data = data[:, :, idx].astype(np.float32) # Ensure float32 for processing
        
        # 1. Process slice for high-resolution (using the provided function, no simulation here)
        # This function should handle normalization and resizing to target_size
        hr_processed_slice = preprocess_function(slice_data, target_size, 
                                               apply_simulation=False) # Force apply_simulation=False for HR
        
        # Generate filename (same for both HR and LR to maintain pairing)
        filename = generate_filename(subject, idx, timepoint)
        
        # Save the high-resolution slice
        hr_output_path = os.path.join(hr_output_dir, filename)
        # Convert from float [0,1] to uint8 [0,255] for saving
        hr_processed_uint8 = np.clip(hr_processed_slice * 255, 0, 255).astype(np.uint8)
        cv2.imwrite(hr_output_path, hr_processed_uint8)
        print(f"Saved HR: {hr_output_path}")
        
        # 2. If low-resolution output directory is provided, create LR version
        if lr_output_dir is not None and apply_simulation:
            # a. Normalize the original slice data robustly to [0, 1] before simulation
            #    (Simulation functions expect data in this range)
            normalized_slice = robust_normalize(slice_data, lower_percentile=0.5, upper_percentile=99.5, target_range=(0, 1))
            
            # b. Apply simulation to the normalized slice
            if use_kspace_simulation:
                simulated_slice = simulate_low_field_mri(normalized_slice, 
                                                         kspace_crop_factor=kspace_crop_factor, 
                                                         noise_std=noise_std)
            else:
                simulated_slice = simulate_15T_data(normalized_slice, 
                                                   noise_std=noise_std, 
                                                   blur_sigma=blur_sigma)
            
            # c. Clip after simulation to ensure values stay in [0, 1] range
            simulated_slice = np.clip(simulated_slice, 0, 1)

            # d. Calculate LR target size (half of HR target size)
            lr_target_size = (target_size[0] // 2, target_size[1] // 2)
            
            # e. Downsample the simulated slice using letterbox_resize to preserve aspect ratio
            lr_processed_slice = letterbox_resize(
                simulated_slice,
                lr_target_size,
                interpolation=InterpolationMethod.AREA
            )

            # Save the low-resolution slice
            lr_output_path = os.path.join(lr_output_dir, filename)
            # Convert from float [0,1] to uint8 [0,255] for saving
            lr_processed_uint8 = np.clip(lr_processed_slice * 255, 0, 255).astype(np.uint8)
            cv2.imwrite(lr_output_path, lr_processed_uint8)
            print(f"Saved LR: {lr_output_path} (Size: {lr_target_size})") 